"""File handling utilities for Claude handler.

This module provides file processing and delivery functions for generated
content from tool executions.

NO __init__.py - use direct import:
    from telegram.handlers.claude_files import process_generated_files
"""

from datetime import datetime
from datetime import timedelta
from datetime import timezone

from aiogram import types
from config import FILES_API_TTL_HOURS
from core.claude.files_api import upload_to_files_api
from db.models.user_file import FileSource
from db.models.user_file import FileType
from db.repositories.user_file_repository import UserFileRepository
from sqlalchemy.ext.asyncio import AsyncSession
from utils.structured_logging import get_logger

logger = get_logger(__name__)


async def process_generated_files(
    result: dict,
    first_message: types.Message,
    _thread_id: int,
    _session: AsyncSession,
    user_file_repo: UserFileRepository,
    chat_id: int,
    user_id: int,
    telegram_thread_id: int | None,
) -> None:
    """Process and deliver files generated by tools.

    Handles the _file_contents pattern: extracts files from tool results,
    uploads to Files API, sends to Telegram, and saves to database.

    Args:
        result: Tool result dict containing _file_contents.
        first_message: First message in batch (for bot reference).
        _thread_id: Internal thread ID.
        _session: Database session.
        user_file_repo: UserFile repository.
        chat_id: Telegram chat ID.
        user_id: User ID for logging.
        telegram_thread_id: Telegram thread ID (for forums).
    """
    file_contents = result.pop("_file_contents")
    delivered_files = []  # List of {filename, claude_file_id, file_type}

    for file_data in file_contents:
        try:
            filename = file_data["filename"]
            file_bytes = file_data["content"]
            mime_type = file_data["mime_type"]

            # Upload to Files API
            claude_file_id = await upload_to_files_api(file_bytes=file_bytes,
                                                       filename=filename,
                                                       mime_type=mime_type)

            # Determine file type
            if mime_type.startswith("image/"):
                file_type = FileType.IMAGE
            elif mime_type == "application/pdf":
                file_type = FileType.PDF
            else:
                file_type = FileType.DOCUMENT

            # Send to Telegram
            telegram_file_id = None
            telegram_file_unique_id = None

            if file_type == FileType.IMAGE and mime_type in [
                    "image/jpeg", "image/png", "image/gif", "image/webp"
            ]:
                sent_msg = await first_message.bot.send_photo(
                    chat_id=chat_id,
                    photo=types.BufferedInputFile(file_bytes,
                                                  filename=filename),
                    message_thread_id=telegram_thread_id)
                if sent_msg.photo:
                    largest = max(sent_msg.photo,
                                  key=lambda p: p.file_size or 0)
                    telegram_file_id = largest.file_id
                    telegram_file_unique_id = largest.file_unique_id
            else:
                sent_msg = await first_message.bot.send_document(
                    chat_id=chat_id,
                    document=types.BufferedInputFile(file_bytes,
                                                     filename=filename),
                    message_thread_id=telegram_thread_id)
                if sent_msg.document:
                    telegram_file_id = sent_msg.document.file_id
                    telegram_file_unique_id = sent_msg.document.file_unique_id

            # Save to database
            await user_file_repo.create(
                message_id=first_message.message_id,
                telegram_file_id=telegram_file_id,
                telegram_file_unique_id=telegram_file_unique_id,
                claude_file_id=claude_file_id,
                filename=filename,
                file_type=file_type,
                mime_type=mime_type,
                file_size=len(file_bytes),
                source=FileSource.ASSISTANT,
                expires_at=datetime.now(timezone.utc) +
                timedelta(hours=FILES_API_TTL_HOURS),
                file_metadata={},
            )

            # Store file info with claude_file_id for tool result
            delivered_files.append({
                "filename": filename,
                "claude_file_id": claude_file_id,
                "file_type": file_type.value,
            })

            # Dashboard tracking event (must match Grafana query)
            logger.info("files.bot_file_sent",
                        user_id=user_id,
                        file_type=file_type.value,
                        filename=filename)

        except Exception as e:  # pylint: disable=broad-exception-caught
            logger.error("stream.file_delivery_failed",
                         filename=file_data.get("filename"),
                         error=str(e),
                         exc_info=True)

    if delivered_files:
        # Format result with claude_file_id so Claude can reference files
        file_list = "\n".join(f"- {f['filename']} ({f['file_type']}): "
                              f"claude_file_id={f['claude_file_id']}"
                              for f in delivered_files)
        result["files_delivered"] = (
            f"Successfully sent {len(delivered_files)} file(s) to user:\n"
            f"{file_list}\n\n"
            f"Use these claude_file_id values with analyze_image or "
            f"analyze_pdf tools if you need to analyze the files.")
