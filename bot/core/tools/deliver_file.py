"""Deliver cached execution file to user.

This module implements the deliver_file tool for sending files
generated by execute_python from Redis cache to the user.

Phase 3.2+: Files generated by execute_python are cached in Redis.
The model decides whether to deliver files based on user request
and file quality. This tool retrieves cached files and delivers them.

NO __init__.py - use direct import:
    from core.tools.deliver_file import deliver_file, DELIVER_FILE_TOOL
"""

from typing import Any, Dict, TYPE_CHECKING

from cache.exec_cache import delete_exec_file
from cache.exec_cache import get_exec_file
from cache.exec_cache import get_exec_meta
from utils.structured_logging import get_logger

if TYPE_CHECKING:
    from aiogram import Bot
    from sqlalchemy.ext.asyncio import AsyncSession

logger = get_logger(__name__)

# Tool definition for Claude API
DELIVER_FILE_TOOL = {
    "name":
        "deliver_file",
    "description":
        """Deliver a cached file from execute_python to the user.

<purpose>
Send files generated by execute_python to the user. Files are temporarily
cached in Redis (30 min TTL) until you decide to deliver them. This gives
you control over what files users receive - you can verify quality, filter
irrelevant outputs, or regenerate if needed before delivery.
</purpose>

<workflow>
1. execute_python generates files â†’ cached with temp_id + preview
2. You review output_files metadata (filename, size, preview)
3. If file looks good â†’ call deliver_file(temp_id="...")
4. File sent to user, appears in "Available files" for future use

Preview examples:
- "Image 800x600 (RGB), 45.2 KB" - PNG chart looks reasonable
- "PDF, ~3 pages, 125 KB" - PDF report with expected size
- "CSV, 1,234 rows Ã— 5 cols, 89 KB" - data export complete
</workflow>

<when_to_deliver>
DELIVER when:
- User explicitly requested the file ("create chart", "generate PDF")
- Preview shows correct format and reasonable size
- File is the final output user needs

DO NOT DELIVER when:
- Preview shows suspiciously small size (likely failed conversion)
- File is intermediate/temporary (debug logs, temp data)
- User didn't ask for a file explicitly
- Quality is uncertain â†’ verify with analyze_pdf/analyze_image first
</when_to_deliver>

<verification>
For important deliveries, verify before sending:
1. Check preview in output_files (size, format, dimensions)
2. If uncertain, deliver first then analyze:
   - Call deliver_file â†’ file appears in "Available files"
   - Call analyze_pdf or analyze_image to verify content
   - If problems found, regenerate with execute_python
</verification>

<cache_expiry>
Files expire after 30 minutes. If temp_id not found:
- Inform user that file expired
- Regenerate with execute_python if still needed
</cache_expiry>""",
    "input_schema": {
        "type": "object",
        "properties": {
            "temp_id": {
                "type":
                    "string",
                "description":
                    ("Temporary file ID from execute_python's output_files "
                     "list (e.g., 'exec_abc123_chart.png'). Find in the "
                     "output_files array from execute_python result.")
            },
            "caption": {
                "type":
                    "string",
                "description":
                    ("Optional brief caption (1-2 sentences). Use for context "
                     "like 'Sales report for Q4' or 'Chart showing trend'. "
                     "Omit if file name is self-explanatory.")
            }
        },
        "required": ["temp_id"]
    },
}


async def deliver_file(
    temp_id: str,
    bot: 'Bot',  # pylint: disable=unused-argument
    session: 'AsyncSession',  # pylint: disable=unused-argument
    caption: str | None = None,
) -> Dict[str, Any]:
    """Deliver cached execution file to user.

    Retrieves file from Redis cache and prepares it for delivery
    via the _file_contents pattern (handled by claude handler).

    Args:
        temp_id: Temporary file ID from execute_python output_files.
        bot: Telegram Bot instance (unused, for interface consistency).
        session: Database session (unused, for interface consistency).
        caption: Optional caption for the file (unused in tool result,
            but can be included in response message).

    Returns:
        Dictionary with delivery result:
        - On success: {"success": "true", "_file_contents": [...]}
        - On failure: {"success": "false", "error": "..."}

    Examples:
        >>> result = await deliver_file(
        ...     temp_id="exec_abc123_chart.png",
        ...     bot=bot,
        ...     session=session
        ... )
        >>> print(result['success'])
        true
    """
    logger.info("tools.deliver_file.called",
                temp_id=temp_id,
                has_caption=bool(caption))

    try:
        # Step 1: Get metadata from cache
        metadata = await get_exec_meta(temp_id)
        if metadata is None:
            logger.warning("tools.deliver_file.meta_not_found", temp_id=temp_id)
            return {
                "success":
                    "false",
                "error": (f"File '{temp_id}' not found in cache. "
                          "It may have expired (30 min TTL). "
                          "Use execute_python to regenerate the file."),
            }

        # Step 2: Get file content from cache
        content = await get_exec_file(temp_id)
        if content is None:
            logger.warning("tools.deliver_file.content_not_found",
                           temp_id=temp_id)
            return {
                "success":
                    "false",
                "error": (f"File content for '{temp_id}' not found. "
                          "It may have expired (30 min TTL). "
                          "Use execute_python to regenerate the file."),
            }

        filename = metadata["filename"]
        mime_type = metadata["mime_type"]
        size_bytes = len(content)

        logger.info("tools.deliver_file.file_retrieved",
                    temp_id=temp_id,
                    filename=filename,
                    mime_type=mime_type,
                    size_bytes=size_bytes)

        # Step 3: Delete from cache (file will be in Files API after delivery)
        # This prevents duplicate delivery and frees cache space
        deleted = await delete_exec_file(temp_id)
        if deleted:
            logger.debug("tools.deliver_file.cache_cleaned", temp_id=temp_id)

        # Step 4: Return with _file_contents for handler processing
        # Handler will: upload to Files API, send to Telegram, save to DB
        result: Dict[str, Any] = {
            "success":
                "true",
            "_file_contents": [{
                "filename": filename,
                "content": content,
                "mime_type": mime_type,
            }],
        }

        # Include caption in result for potential use in response
        if caption:
            result["caption"] = caption

        logger.info("tools.deliver_file.success",
                    temp_id=temp_id,
                    filename=filename,
                    size_bytes=size_bytes)

        return result

    except Exception as e:
        logger.error("tools.deliver_file.failed",
                     temp_id=temp_id,
                     error=str(e),
                     exc_info=True)
        return {
            "success": "false",
            "error": f"Failed to deliver file: {str(e)}",
        }


def format_deliver_file_result(
    tool_input: Dict[str, Any],
    result: Dict[str, Any],
) -> str:
    """Format deliver_file result for user display.

    Args:
        tool_input: The input parameters (temp_id, caption).
        result: The result dictionary with success, error.

    Returns:
        Formatted system message string.
    """
    if result.get("success") == "true":
        # File delivered - message comes from files_delivered in handler
        return ""  # No extra message needed, file speaks for itself
    else:
        error = result.get("error", "unknown error")
        preview = error[:80] + "..." if len(error) > 80 else error
        return f"[Failed to deliver file: {preview}]"


# Unified tool configuration
from core.tools.base import ToolConfig  # pylint: disable=wrong-import-position

TOOL_CONFIG = ToolConfig(
    name="deliver_file",
    definition=DELIVER_FILE_TOOL,
    executor=deliver_file,
    emoji="ðŸ“¤",
    needs_bot_session=True,
    format_result=format_deliver_file_result,
)
