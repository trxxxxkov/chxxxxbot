"""Deliver cached execution file to user.

This module implements the deliver_file tool for sending files
generated by execute_python from Redis cache to the user.

Phase 3.2+: Files generated by execute_python are cached in Redis.
The model decides whether to deliver files based on user request
and file quality. This tool retrieves cached files and delivers them.

NO __init__.py - use direct import:
    from core.tools.deliver_file import deliver_file, DELIVER_FILE_TOOL
"""

from typing import Any, Dict, TYPE_CHECKING

from cache.exec_cache import delete_exec_file
from cache.exec_cache import get_exec_file
from cache.exec_cache import get_exec_meta
from utils.structured_logging import get_logger

if TYPE_CHECKING:
    from aiogram import Bot
    from sqlalchemy.ext.asyncio import AsyncSession

logger = get_logger(__name__)

# Tool definition for Claude API
DELIVER_FILE_TOOL = {
    "name":
        "deliver_file",
    "description":
        """Deliver a cached file from execute_python to the user.

After execute_python generates files, you receive output_files metadata.
Use this tool to send files to the user when:
- User explicitly requested the file (e.g., "create a chart", "generate PDF")
- You verified the file quality via preview or validation tools
- The file is relevant to the conversation

The file is retrieved from temporary cache (30 min TTL) and sent to user.
After delivery, file becomes available in "Available files" for future use.

Input: temp_id from execute_python's output_files list.
Output: File is sent to user, claude_file_id returned for future reference.

Note: Files expire after 30 minutes. Deliver promptly or regenerate if expired.""",
    "input_schema": {
        "type": "object",
        "properties": {
            "temp_id": {
                "type":
                    "string",
                "description": ("Temporary file ID from execute_python's "
                                "output_files (e.g., 'exec_abc123_chart.png').")
            },
            "caption": {
                "type":
                    "string",
                "description": ("Optional caption to send with the file. "
                                "Keep it brief (1-2 sentences max). "
                                "Omit if file is self-explanatory.")
            }
        },
        "required": ["temp_id"]
    },
}


async def deliver_file(
    temp_id: str,
    bot: 'Bot',  # pylint: disable=unused-argument
    session: 'AsyncSession',  # pylint: disable=unused-argument
    caption: str | None = None,
) -> Dict[str, Any]:
    """Deliver cached execution file to user.

    Retrieves file from Redis cache and prepares it for delivery
    via the _file_contents pattern (handled by claude handler).

    Args:
        temp_id: Temporary file ID from execute_python output_files.
        bot: Telegram Bot instance (unused, for interface consistency).
        session: Database session (unused, for interface consistency).
        caption: Optional caption for the file (unused in tool result,
            but can be included in response message).

    Returns:
        Dictionary with delivery result:
        - On success: {"success": "true", "_file_contents": [...]}
        - On failure: {"success": "false", "error": "..."}

    Examples:
        >>> result = await deliver_file(
        ...     temp_id="exec_abc123_chart.png",
        ...     bot=bot,
        ...     session=session
        ... )
        >>> print(result['success'])
        true
    """
    logger.info("tools.deliver_file.called",
                temp_id=temp_id,
                has_caption=bool(caption))

    try:
        # Step 1: Get metadata from cache
        metadata = await get_exec_meta(temp_id)
        if metadata is None:
            logger.warning("tools.deliver_file.meta_not_found", temp_id=temp_id)
            return {
                "success":
                    "false",
                "error": (f"File '{temp_id}' not found in cache. "
                          "It may have expired (30 min TTL). "
                          "Use execute_python to regenerate the file."),
            }

        # Step 2: Get file content from cache
        content = await get_exec_file(temp_id)
        if content is None:
            logger.warning("tools.deliver_file.content_not_found",
                           temp_id=temp_id)
            return {
                "success":
                    "false",
                "error": (f"File content for '{temp_id}' not found. "
                          "It may have expired (30 min TTL). "
                          "Use execute_python to regenerate the file."),
            }

        filename = metadata["filename"]
        mime_type = metadata["mime_type"]
        size_bytes = len(content)

        logger.info("tools.deliver_file.file_retrieved",
                    temp_id=temp_id,
                    filename=filename,
                    mime_type=mime_type,
                    size_bytes=size_bytes)

        # Step 3: Delete from cache (file will be in Files API after delivery)
        # This prevents duplicate delivery and frees cache space
        deleted = await delete_exec_file(temp_id)
        if deleted:
            logger.debug("tools.deliver_file.cache_cleaned", temp_id=temp_id)

        # Step 4: Return with _file_contents for handler processing
        # Handler will: upload to Files API, send to Telegram, save to DB
        result: Dict[str, Any] = {
            "success":
                "true",
            "_file_contents": [{
                "filename": filename,
                "content": content,
                "mime_type": mime_type,
            }],
        }

        # Include caption in result for potential use in response
        if caption:
            result["caption"] = caption

        logger.info("tools.deliver_file.success",
                    temp_id=temp_id,
                    filename=filename,
                    size_bytes=size_bytes)

        return result

    except Exception as e:
        logger.error("tools.deliver_file.failed",
                     temp_id=temp_id,
                     error=str(e),
                     exc_info=True)
        return {
            "success": "false",
            "error": f"Failed to deliver file: {str(e)}",
        }


def format_deliver_file_result(
    tool_input: Dict[str, Any],
    result: Dict[str, Any],
) -> str:
    """Format deliver_file result for user display.

    Args:
        tool_input: The input parameters (temp_id, caption).
        result: The result dictionary with success, error.

    Returns:
        Formatted system message string.
    """
    if result.get("success") == "true":
        # File delivered - message comes from files_delivered in handler
        return ""  # No extra message needed, file speaks for itself
    else:
        error = result.get("error", "unknown error")
        preview = error[:80] + "..." if len(error) > 80 else error
        return f"[Failed to deliver file: {preview}]"


# Unified tool configuration
from core.tools.base import ToolConfig  # pylint: disable=wrong-import-position

TOOL_CONFIG = ToolConfig(
    name="deliver_file",
    definition=DELIVER_FILE_TOOL,
    executor=deliver_file,
    emoji="ðŸ“¤",
    needs_bot_session=True,
    format_result=format_deliver_file_result,
)
