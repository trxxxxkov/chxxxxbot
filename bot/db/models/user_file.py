"""UserFile model for Files API integration.

This module defines the UserFile model which stores metadata for files
uploaded to Claude Files API (Phase 1.5: Multimodal + Tools).

Files lifecycle:
- User uploads file → Telegram → Bot downloads → Files API upload → DB record
- Files expire after FILES_API_TTL_HOURS (default: 24h)
- Cleanup cron job deletes expired files from Files API and DB

NO __init__.py - use direct import:
    from db.models.user_file import UserFile, FileType, FileSource
"""

from datetime import datetime
import enum
from typing import Optional

from db.models.base import Base
from sqlalchemy import BigInteger
from sqlalchemy import DateTime
from sqlalchemy import Enum
from sqlalchemy import func
from sqlalchemy import Index
from sqlalchemy import Integer
from sqlalchemy import JSON
from sqlalchemy import String
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column


class FileType(str, enum.Enum):
    """File type classification for Files API.

    Phase 1.6: Extended with audio/video types.

    Attributes:
        IMAGE: Photo or image file (JPEG, PNG, GIF, WebP).
        PDF: PDF document.
        DOCUMENT: Other documents (text, CSV, etc.).
        AUDIO: Audio file (MP3, FLAC, WAV, M4A, etc.).
        VOICE: Voice message (OGG/OPUS format from Telegram).
        VIDEO: Video file (MP4, MOV, AVI, etc.).
        GENERATED: File generated by assistant (e.g., code execution output).
    """

    IMAGE = "image"
    PDF = "pdf"
    DOCUMENT = "document"
    AUDIO = "audio"  # Phase 1.6
    VOICE = "voice"  # Phase 1.6
    VIDEO = "video"  # Phase 1.6
    GENERATED = "generated"


class FileSource(str, enum.Enum):
    """Source of the file.

    Attributes:
        USER: File uploaded by user via Telegram.
        ASSISTANT: File generated by assistant (e.g., via tool).
    """

    USER = "user"
    ASSISTANT = "assistant"


class UserFile(Base):
    """File uploaded to Claude Files API.

    Stores metadata for files uploaded to Files API. Files are referenced
    by claude_file_id in tool calls (analyze_image, analyze_pdf).

    Attributes:
        id: Primary key.
        message_id: Message that contains this file (FK to messages).
        telegram_file_id: Telegram file ID (for user uploads).
        telegram_file_unique_id: Telegram unique file ID.
        claude_file_id: Files API file ID (unique).
        filename: Original filename.
        file_type: Type classification (image/pdf/document/generated).
        mime_type: MIME type (e.g., image/jpeg, application/pdf).
        file_size: Size in bytes.
        uploaded_at: Upload timestamp.
        expires_at: Expiration timestamp (uploaded_at + FILES_API_TTL_HOURS).
        source: Who created the file (user/assistant).
        metadata: Optional JSONB metadata (width, height, page_count, etc.).
    """

    __tablename__ = "user_files"

    # Primary key
    id: Mapped[int] = mapped_column(
        Integer,
        primary_key=True,
        doc="Primary key",
    )

    # Message reference (NOT FK - messages have composite PK)
    message_id: Mapped[int] = mapped_column(
        BigInteger,
        nullable=False,
        doc="Message ID that contains this file",
    )

    # Telegram data (for user uploads)
    telegram_file_id: Mapped[Optional[str]] = mapped_column(
        String,
        nullable=True,
        doc="Telegram file ID (if from user upload)",
    )

    telegram_file_unique_id: Mapped[Optional[str]] = mapped_column(
        String,
        nullable=True,
        doc="Telegram unique file ID",
    )

    # Claude Files API data
    claude_file_id: Mapped[str] = mapped_column(
        String,
        nullable=False,
        unique=True,
        doc="Files API file ID (unique)",
    )

    # Metadata
    filename: Mapped[str] = mapped_column(
        String,
        nullable=False,
        doc="Original filename",
    )

    file_type: Mapped[FileType] = mapped_column(
        Enum(FileType,
             name='filetype',
             values_callable=lambda x: [e.value for e in x]),
        nullable=False,
        doc="File type classification",
    )

    mime_type: Mapped[str] = mapped_column(
        String,
        nullable=False,
        doc="MIME type (e.g., image/jpeg)",
    )

    file_size: Mapped[int] = mapped_column(
        Integer,
        nullable=False,
        doc="Size in bytes",
    )

    # Lifecycle
    uploaded_at: Mapped[datetime] = mapped_column(
        DateTime,
        server_default=func.now(),
        nullable=False,
        doc="Upload timestamp",
    )

    expires_at: Mapped[datetime] = mapped_column(
        DateTime,
        nullable=False,
        doc="Expiration timestamp (uploaded_at + FILES_API_TTL_HOURS)",
    )

    # Source
    source: Mapped[FileSource] = mapped_column(
        Enum(FileSource,
             name='filesource',
             values_callable=lambda x: [e.value for e in x]),
        nullable=False,
        doc="Who created the file (user/assistant)",
    )

    # Optional file metadata (JSON - compatible with PostgreSQL and SQLite)
    # Note: 'metadata' name is reserved by SQLAlchemy, use 'file_metadata'
    file_metadata: Mapped[Optional[dict]] = mapped_column(
        "metadata",  # Column name in database
        JSON,
        nullable=True,
        doc="Optional metadata (width, height, page_count, etc.)",
    )

    # Indexes
    __table_args__ = (
        # Index for finding files by message
        Index("idx_user_files_message_id", "message_id"),
        # Unique index for claude_file_id
        Index("idx_user_files_claude_file_id", "claude_file_id", unique=True),
        # Index for cleanup cron (expired files)
        Index("idx_user_files_expires_at", "expires_at"),
        # Index for filtering by file type
        Index("idx_user_files_file_type", "file_type"),
    )

    def __repr__(self) -> str:
        """String representation for debugging.

        Returns:
            UserFile representation with id, filename, and type.
        """
        return (f"<UserFile(id={self.id}, filename='{self.filename}', "
                f"type={self.file_type.value})>")
